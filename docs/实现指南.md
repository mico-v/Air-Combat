# 实现指南 - 如何使用本框架

本文档为零基础学习者提供详细的框架使用指南，从头到尾带你完成一个简单的飞机大战游戏。

## 📋 前提条件

在开始之前，请确保已经完成：
1. ✅ 阅读了 `README.md` - 了解项目概况
2. ✅ 阅读了 `SETUP.md` - 完成环境搭建
3. ✅ Visual Studio 已正确安装并可以编译 C++ 项目

## 🎯 学习目标

通过本指南，你将学会：
- 如何使用框架提供的工具函数
- 如何处理用户输入（键盘和鼠标）
- 如何实现游戏循环
- 如何绘制游戏画面
- 如何检测碰撞
- 如何管理游戏对象

## 📚 学习路线

### 第一阶段：理解框架结构（1-2天）

#### 步骤 1：阅读核心文档
- 📖 `docs/02-框架概览.md` - 理解三层架构
- 📖 `docs/快速参考.md` - 熟悉常用函数
- 📖 `docs/API文档.md` - 需要时查阅

#### 步骤 2：理解数据结构
打开并阅读以下文件（顺序很重要）：
1. `src/util/config.h` - 了解所有可配置的参数
2. `src/util/type.h` - 理解基本数据类型
3. `src/util/util.h` - 了解可用的工具函数

**学习建议：**
- 不要试图记住所有内容
- 重点理解 Vector2、Rect、Circle 的用途
- 记住可以用 Clamp、Normalize 等函数

#### 步骤 3：实践输入处理
阅读并运行以下示例：
1. `src/util/keyboard.h` - 了解如何检测按键
2. `src/util/mouse.h` - 了解如何获取鼠标位置

**动手练习：**
```cpp
// 练习 1：检测 WASD 移动
Vector2 direction = {0, 0};
if (GetKeyDown('W')) direction.y -= 1;
if (GetKeyDown('S')) direction.y += 1;
if (GetKeyDown('A')) direction.x -= 1;
if (GetKeyDown('D')) direction.x += 1;

// 练习 2：获取鼠标位置
int x = GetMouseX();
int y = GetMouseY();
Log(1, TEXT("鼠标位置: (%d, %d)"), x, y);
```

### 第二阶段：实现基础功能（3-5天）

#### 任务 1：创建玩家对象

**需要做什么：**
1. 定义玩家结构体
2. 实现创建、更新、绘制、销毁函数
3. 在场景中使用玩家

**详细步骤：**

**第 1 步：创建玩家头文件** `src/game_object/player.h`

```cpp
#pragma once
#include "../util/type.h"
#include <windows.h>

// 玩家结构体
struct Player
{
    Vector2 position;     // 位置
    double width;         // 宽度
    double height;        // 高度
    Attribute attributes; // 属性（生命、分数等）
};

// 创建玩家
void CreatePlayer();

// 获取玩家指针
Player* GetPlayer();

// 更新玩家
void UpdatePlayer(double deltaTime);

// 绘制玩家
void RenderPlayer(HDC hdc_memBuffer, HDC hdc_loadBmp);

// 销毁玩家
void DestroyPlayer();
```

**第 2 步：实现玩家逻辑** `src/game_object/player.cpp`

```cpp
#include "player.h"
#include "../util/config.h"
#include "../util/util.h"
#include "../util/keyboard.h"

// 全局玩家对象（只有一个玩家）
static Player* player = nullptr;

void CreatePlayer()
{
    player = new Player();
    
    // 设置初始位置（屏幕底部中央）
    player->position.x = (GAME_WIDTH - PLAYER_WIDTH) / 2;
    player->position.y = GAME_HEIGHT - PLAYER_HEIGHT - 20;
    player->width = PLAYER_WIDTH;
    player->height = PLAYER_HEIGHT;
    
    // 设置初始属性
    player->attributes.health = PLAYER_INITIAL_HEALTH;
    player->attributes.score = 0;
    player->attributes.speed = PLAYER_SPEED;
    player->attributes.maxBulletCd = PLAYER_BULLET_COOLDOWN;
    player->attributes.bulletCd = 0.0;
}

Player* GetPlayer()
{
    return player;
}

void UpdatePlayer(double deltaTime)
{
    if (player == nullptr) return;
    
    // 1. 处理移动输入
    Vector2 direction = {0, 0};
    if (GetKeyDown('W') || GetKeyDown(VK_UP))    direction.y -= 1;
    if (GetKeyDown('S') || GetKeyDown(VK_DOWN))  direction.y += 1;
    if (GetKeyDown('A') || GetKeyDown(VK_LEFT))  direction.x -= 1;
    if (GetKeyDown('D') || GetKeyDown(VK_RIGHT)) direction.x += 1;
    
    // 2. 归一化方向（保证所有方向速度一致）
    direction = Normalize(direction);
    
    // 3. 移动玩家
    player->position.x += direction.x * player->attributes.speed * deltaTime;
    player->position.y += direction.y * player->attributes.speed * deltaTime;
    
    // 4. 限制在屏幕内
    player->position.x = Clamp(player->position.x, 0, GAME_WIDTH - player->width);
    player->position.y = Clamp(player->position.y, 0, GAME_HEIGHT - player->height);
    
    // 5. 更新子弹冷却
    if (player->attributes.bulletCd > 0)
        player->attributes.bulletCd -= deltaTime;
}

void RenderPlayer(HDC hdc_memBuffer, HDC hdc_loadBmp)
{
    if (player == nullptr) return;
    
    // 简单绘制：绘制一个矩形代表玩家
    RECT rect;
    rect.left = (LONG)player->position.x;
    rect.top = (LONG)player->position.y;
    rect.right = (LONG)(player->position.x + player->width);
    rect.bottom = (LONG)(player->position.y + player->height);
    
    // 创建画刷（蓝色）
    HBRUSH brush = CreateSolidBrush(RGB(0, 0, 255));
    FillRect(hdc_memBuffer, &rect, brush);
    DeleteObject(brush);
}

void DestroyPlayer()
{
    if (player != nullptr)
    {
        delete player;
        player = nullptr;
    }
}
```

**第 3 步：测试玩家功能**

在场景的 UpdateScene 中调用：
```cpp
UpdatePlayer(deltaTime);
```

在场景的 RenderScene 中调用：
```cpp
RenderPlayer(hdc_memBuffer, hdc_loadBmp);
```

**验证清单：**
- [ ] 玩家显示在屏幕上（蓝色矩形）
- [ ] 可以用 WASD 或方向键移动
- [ ] 玩家不会移出屏幕边界
- [ ] 所有方向移动速度一致

#### 任务 2：创建敌人对象

**需要做什么：**
1. 定义敌人结构体（与玩家类似）
2. 实现敌人管理（因为有多个敌人）
3. 实现自动生成和移动

**详细步骤：**

**敌人结构体** - 与玩家类似，但需要管理多个敌人

```cpp
// src/game_object/enemy.h
#pragma once
#include "../util/type.h"
#include <windows.h>
#include <vector>

struct Enemy
{
    Vector2 position;
    double width;
    double height;
    Attribute attributes;
};

void CreateEnemy(double x, double y);
void CreateRandomEnemy();
void UpdateEnemies(double deltaTime);
void RenderEnemies(HDC hdc_memBuffer, HDC hdc_loadBmp);
void DestroyEnemy(Enemy* enemy);
void DestroyEnemies();
std::vector<Enemy*> GetEnemies();
```

**关键实现** - 使用 vector 管理多个敌人

```cpp
// src/game_object/enemy.cpp
static std::vector<Enemy*> enemies;  // 敌人列表

void CreateEnemy(double x, double y)
{
    Enemy* enemy = new Enemy();
    enemy->position.x = x;
    enemy->position.y = y;
    enemy->width = ENEMY_WIDTH;
    enemy->height = ENEMY_HEIGHT;
    enemy->attributes.health = ENEMY_HEALTH;
    enemy->attributes.speed = ENEMY_SPEED;
    enemy->attributes.score = ENEMY_SCORE;
    
    enemies.push_back(enemy);
}

void UpdateEnemies(double deltaTime)
{
    // 定时生成敌人
    static double lastSpawnTime = 0;
    double currentTime = GetGameTime();  // 需要实现
    
    if (currentTime - lastSpawnTime > ENEMY_SPAWN_INTERVAL)
    {
        CreateRandomEnemy();
        lastSpawnTime = currentTime;
    }
    
    // 移动所有敌人
    for (size_t i = 0; i < enemies.size(); )
    {
        Enemy* enemy = enemies[i];
        
        // 向下移动
        enemy->position.y += enemy->attributes.speed * deltaTime;
        
        // 删除超出屏幕的敌人
        if (enemy->position.y > GAME_HEIGHT + 50)
        {
            delete enemy;
            enemies.erase(enemies.begin() + i);
        }
        else
        {
            i++;
        }
    }
}
```

#### 任务 3：实现碰撞检测

**需要做什么：**
使用框架提供的碰撞检测函数检测玩家与敌人的碰撞

```cpp
void CheckCollision()
{
    Player* player = GetPlayer();
    if (player == nullptr) return;
    
    // 创建玩家碰撞矩形
    Rect playerRect = CreateRect(player->position, player->width, player->height);
    
    // 检测与所有敌人的碰撞
    for (Enemy* enemy : GetEnemies())
    {
        Rect enemyRect = CreateRect(enemy->position, enemy->width, enemy->height);
        
        if (IsRectRectCollision(playerRect, enemyRect))
        {
            // 碰撞处理
            player->attributes.health--;
            player->attributes.score += enemy->attributes.score;
            DestroyEnemy(enemy);
            
            // 检查游戏结束
            if (player->attributes.health <= 0)
            {
                // 游戏结束逻辑
                Log(1, TEXT("游戏结束！"));
            }
        }
    }
}
```

### 第三阶段：完善游戏（1-2周）

#### 扩展功能清单

1. **子弹系统**
   - [ ] 创建子弹结构体
   - [ ] 实现发射功能
   - [ ] 实现子弹移动
   - [ ] 实现子弹与敌人碰撞

2. **UI 系统**
   - [ ] 显示生命值和分数
   - [ ] 创建开始按钮
   - [ ] 创建暂停功能

3. **场景管理**
   - [ ] 开始场景
   - [ ] 游戏场景
   - [ ] 游戏结束场景

4. **资源管理**
   - [ ] 加载图片资源
   - [ ] 使用位图代替矩形
   - [ ] 添加音效（可选）

## 🔧 常见问题解决

### 问题 1：对象不显示

**可能原因：**
1. 没有调用 Render 函数
2. 对象位置在屏幕外
3. 绘制顺序错误

**解决方法：**
```cpp
// 在 RenderScene 中确保调用
RenderPlayer(hdc_memBuffer, hdc_loadBmp);
RenderEnemies(hdc_memBuffer, hdc_loadBmp);

// 检查位置
Log(1, TEXT("玩家位置: (%f, %f)"), player->x, player->y);
```

### 问题 2：对象不移动

**可能原因：**
1. 没有调用 Update 函数
2. deltaTime 为 0
3. 速度为 0

**解决方法：**
```cpp
// 在 UpdateScene 中确保调用
UpdatePlayer(deltaTime);
UpdateEnemies(deltaTime);

// 检查 deltaTime
Log(1, TEXT("deltaTime: %f"), deltaTime);
```

### 问题 3：碰撞检测不工作

**可能原因：**
1. 碰撞矩形创建错误
2. 没有调用碰撞检测函数
3. 对象大小设置错误

**解决方法：**
```cpp
// 打印调试信息
Log(1, TEXT("玩家矩形: (%f, %f, %f, %f)"), 
    playerRect.left, playerRect.top, 
    playerRect.right, playerRect.bottom);

// 可视化碰撞框（调试用）
Rectangle(hdc_memBuffer, 
    (int)rect.left, (int)rect.top,
    (int)rect.right, (int)rect.bottom);
```

## 📝 代码检查清单

在提交代码前，请检查：

### 内存管理
- [ ] 所有 new 的对象都有对应的 delete
- [ ] LoadScene 中创建的对象在 UnloadScene 中销毁
- [ ] 没有内存泄漏

### 代码质量
- [ ] 函数命名清晰（使用大驼峰：CreatePlayer）
- [ ] 变量命名清晰（使用小驼峰：playerSpeed）
- [ ] 有适当的注释
- [ ] 没有魔法数字（使用 config.h 中的常量）

### 功能完整性
- [ ] 对象可以正确创建和销毁
- [ ] 移动功能正常
- [ ] 碰撞检测正确
- [ ] UI 显示正确

### 性能
- [ ] 没有不必要的对象创建
- [ ] 碰撞检测没有重复计算
- [ ] 使用 deltaTime 保证帧率独立

## 🎓 进阶学习

完成基础功能后，可以尝试：

1. **优化性能**
   - 使用对象池减少内存分配
   - 优化碰撞检测算法（四叉树）
   - 减少不必要的绘制

2. **添加特效**
   - 粒子系统（爆炸效果）
   - 屏幕震动
   - 慢动作效果

3. **增加玩法**
   - 多种敌人类型
   - 道具系统
   - 关卡系统
   - Boss 战

4. **改进 UI**
   - 菜单系统
   - 设置界面
   - 排行榜

## 📚 推荐学习资源

1. **Win32 编程**
   - Microsoft 官方文档
   - 《Windows 程序设计》

2. **游戏开发**
   - 《游戏编程模式》
   - 《游戏引擎架构》

3. **C++ 编程**
   - 《C++ Primer》
   - 《Effective C++》

## 💡 学习建议

1. **循序渐进**
   - 不要一次实现所有功能
   - 每完成一个功能就测试
   - 遇到问题及时解决

2. **多动手**
   - 不要只看不练
   - 尝试修改参数看效果
   - 自己实现一些小功能

3. **善用工具**
   - 使用调试器（F5、F10、F11）
   - 使用日志输出（Log 函数）
   - 查看文档（F1 键）

4. **寻求帮助**
   - 先查看文档
   - 搜索错误信息
   - 在 GitHub 提 Issue

## 🎯 总结

本框架提供了：
- ✅ 完整的文档系统
- ✅ 详细的代码注释
- ✅ 丰富的工具函数
- ✅ 清晰的架构设计

你需要做的：
- 📖 认真阅读文档
- 💻 动手实践代码
- 🐛 调试解决问题
- 🚀 不断改进优化

祝你学习愉快，创造出精彩的游戏！ 🎮✈️

---

**有问题？**
- 查看 `docs/API文档.md` 了解函数用法
- 查看 `docs/快速参考.md` 查找常用代码
- 在 GitHub 提 Issue 寻求帮助
