# 框架概览

## 一、整体架构

本项目采用分层架构设计，将代码分为三个主要层次：

```
┌─────────────────────────────────────┐
│     Win32 应用程序层                 │
│  (main.cpp, WndProc, 事件处理)       │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│       游戏框架层                     │
│  (core, resource, keyboard, mouse)   │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│      场景逻辑层                      │
│  (scene1, scene2, 游戏对象)          │
└─────────────────────────────────────┘
```

### 为什么要分层？

**好处**：
1. **易于理解**：每一层负责不同的功能，清晰明了
2. **易于维护**：修改某一层不影响其他层
3. **易于扩展**：添加新功能时知道该在哪一层实现
4. **降低耦合**：各层之间通过明确的接口通信

## 二、Win32 应用程序层

### 2.1 什么是 Win32？

Win32 是 Windows 提供的一套 API（应用程序编程接口），用于创建 Windows 桌面应用程序。

### 2.2 核心文件

#### main.cpp - 程序入口

**作用**：
- 程序的起点，Windows 从这里开始执行
- 创建应用程序窗口
- 处理系统消息（事件）

**关键函数**：

```cpp
// 程序入口函数
int APIENTRY wWinMain(
    HINSTANCE hInstance,      // 程序实例句柄
    HINSTANCE hPrevInstance,  // 上一个实例（已废弃，总是 NULL）
    LPWSTR    lpCmdLine,      // 命令行参数
    int       nCmdShow)       // 窗口显示方式
{
    // 1. 注册窗口类
    // 2. 创建窗口
    // 3. 显示窗口
    // 4. 消息循环
}
```

**消息循环**：

```cpp
// 主消息循环：不断检查是否有新的事件发生
while (GetMessage(&msg, nullptr, 0, 0))
{
    TranslateMessage(&msg);   // 转换键盘消息
    DispatchMessage(&msg);    // 分发消息到 WndProc 处理
}
```

#### WndProc - 窗口过程函数

**作用**：
- 响应各种事件（鼠标、键盘、绘图等）
- 相当于游戏的"事件调度中心"

**处理的主要事件**：

| 事件类型 | 说明 | 我们做什么 |
|---------|------|-----------|
| `WM_CREATE` | 窗口创建完成 | 初始化游戏 `GameInit()` |
| `WM_TIMER` | 定时器触发 | 更新游戏逻辑 `GameLoop()` |
| `WM_PAINT` | 需要绘制窗口 | 绘制游戏画面 `GameRender()` |
| `WM_KEYDOWN` | 按下键盘按键 | 记录按键状态 |
| `WM_KEYUP` | 释放键盘按键 | 更新按键状态 |
| `WM_LBUTTONDOWN` | 按下鼠标左键 | 记录鼠标状态 |
| `WM_MOUSEMOVE` | 鼠标移动 | 更新鼠标位置 |
| `WM_DESTROY` | 窗口关闭 | 清理资源 |

**示例代码**：

```cpp
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_CREATE:
        // 窗口创建时，初始化游戏
        GameInit(hWnd, wParam, lParam);
        // 设置定时器，每 16 毫秒触发一次（约 60 FPS）
        SetTimer(hWnd, 1, 16, NULL);
        break;
        
    case WM_TIMER:
        // 定时器触发时，更新游戏逻辑
        GameLoop(hWnd);
        break;
        
    case WM_PAINT:
        // 需要绘制时，绘制游戏画面
        GameRender(hWnd, wParam, lParam);
        break;
        
    // ... 其他事件处理
    }
}
```

### 2.3 其他支持文件

- **config.h**：配置文件，定义窗口大小、游戏区域等常量
- **stdafx.h**：预编译头文件，加快编译速度
- **timer.h**：定时器相关配置

## 三、游戏框架层

### 3.1 核心模块 (core)

#### core.h / core.cpp

**作用**：游戏的核心控制中心

**主要函数**：

1. **GameInit() - 游戏初始化**
   ```cpp
   void GameInit(HWND hWnd, WPARAM wParam, LPARAM lParam)
   {
       // 做什么？
       // 1. 加载游戏资源（图片、音效等）
       // 2. 初始化游戏时间系统
       // 3. 切换到开始场景
   }
   ```

2. **GameLoop() - 游戏循环**
   ```cpp
   void GameLoop(HWND hWnd)
   {
       // 做什么？
       // 1. 计算时间间隔（DeltaTime）
       // 2. 调用场景更新函数
       // 3. 请求重绘窗口
       
       // 为什么需要 DeltaTime？
       // 因为不同电脑性能不同，帧率可能不同
       // 用时间间隔可以保证游戏速度在所有电脑上一致
   }
   ```

3. **GameRender() - 游戏渲染**
   ```cpp
   void GameRender(HWND hWnd, WPARAM wParam, LPARAM lParam)
   {
       // 做什么？
       // 1. 创建内存缓冲区（双缓冲技术）
       // 2. 在缓冲区上绘制游戏画面
       // 3. 一次性将缓冲区内容显示到窗口
       
       // 为什么要双缓冲？
       // 防止画面闪烁，保证流畅度
   }
   ```

#### 游戏时间系统

**关键概念**：

- **游戏时间 (GameTime)**：游戏开始后经过的总时间
- **帧间隔 (DeltaTime)**：上一帧到这一帧的时间差
- **帧率 (FPS)**：每秒渲染的帧数

**为什么重要**：
```cpp
// 错误做法：
player.x += 5;  // 每帧移动 5 像素
// 问题：60 FPS 时每秒移动 300 像素，30 FPS 时每秒移动 150 像素

// 正确做法：
player.x += speed * deltaTime;  // speed = 300 像素/秒
// 好处：无论帧率如何，每秒都移动 300 像素
```

### 3.2 资源管理 (resource)

#### resource.h / resource.cpp

**作用**：统一管理游戏资源

**包含的资源**：
- 位图图片（玩家、敌人、UI 等）
- 字符串（可选）
- 其他资源

**加载流程**：

```cpp
// 1. 声明资源变量（在 resource.h 中）
extern HBITMAP bmp_Player;      // 玩家飞机图片
extern HBITMAP bmp_Enemy;       // 敌人飞机图片
extern HBITMAP bmp_StartButton; // 开始按钮图片

// 2. 在初始化函数中加载（在 resource.cpp 中）
void GameResourceInit(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    // 加载位图资源
    bmp_Player = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_BITMAP_PLANE));
    bmp_Enemy = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_BITMAP_ENEMY));
    // ...
}

// 3. 在其他文件中使用
// 在需要使用的 cpp 文件开头声明
extern HBITMAP bmp_Player;
// 然后就可以使用了
SelectObject(hdc, bmp_Player);
```

### 3.3 输入系统

#### keyboard.h / keyboard.cpp - 键盘输入

**主要函数**：

```cpp
// 设置按键状态（在 WndProc 中调用）
void KeyDown(HWND hWnd, WPARAM wParam, LPARAM lParam);
void KeyUp(HWND hWnd, WPARAM wParam, LPARAM lParam);

// 查询按键状态（在游戏逻辑中调用）
bool GetKeyDown(int keycode);  // 某个键是否正在被按下

// 使用示例：
if (GetKeyDown(VK_SPACE))  // 如果按下空格键
{
    // 发射子弹
}
```

**常用按键代码**：
- `VK_SPACE` - 空格键
- `VK_UP`, `VK_DOWN`, `VK_LEFT`, `VK_RIGHT` - 方向键
- `VK_W`, `VK_A`, `VK_S`, `VK_D` - WASD 键
- `VK_RETURN` - 回车键
- `VK_ESCAPE` - ESC 键

#### mouse.h / mouse.cpp - 鼠标输入

**主要函数**：

```cpp
// 设置鼠标状态（在 WndProc 中调用）
void MouseMove(HWND hWnd, WPARAM wParam, LPARAM lParam);
void LButtonDown(HWND hWnd, WPARAM wParam, LPARAM lParam);
void LButtonUp(HWND hWnd, WPARAM wParam, LPARAM lParam);

// 查询鼠标状态（在游戏逻辑中调用）
int GetMouseX();                // 获取鼠标 X 坐标
int GetMouseY();                // 获取鼠标 Y 坐标
bool IsMouseLButtonDown();      // 鼠标左键是否按下

// 使用示例：
if (IsMouseLButtonDown())
{
    int x = GetMouseX();
    int y = GetMouseY();
    // 检查是否点击了按钮
    PressButtons(x, y);
}
```

## 四、场景逻辑层

### 4.1 场景系统 (scene)

#### 什么是场景？

场景就像游戏的"不同页面"，每个场景有自己的：
- 显示内容（UI、游戏对象等）
- 更新逻辑
- 用户交互

**本游戏的场景**：
1. **开始场景 (StartScene)**：显示标题和开始按钮
2. **游戏场景 (GameScene)**：实际的游戏画面

#### scene.h / scene.cpp - 场景管理

**核心概念**：

```cpp
// 场景 ID 枚举
enum SceneId
{
    None = 0,          // 无场景
    StartScene = 1,    // 开始场景
    GameScene = 2      // 游戏场景
};

// 场景结构体
struct Scene
{
    SceneId sceneId;   // 当前场景 ID
    // 可以添加更多场景相关的数据
};
```

**场景切换**：

```cpp
// 切换场景很简单
ChangeScene(GameScene);  // 切换到游戏场景
```

**场景生命周期**：

每个场景都有 6 个关键函数：

| 函数名 | 调用时机 | 作用 |
|-------|---------|------|
| `LoadScene` | 场景加载时 | 创建游戏对象、初始化变量 |
| `UnloadScene` | 场景卸载时 | 销毁游戏对象、释放资源 |
| `ProcessUiInput` | 每帧开始 | 处理 UI 交互（按钮点击等） |
| `CheckCollision` | 每帧中期 | 检测碰撞 |
| `UpdateScene` | 每帧 | 更新游戏逻辑 |
| `RenderScene` | 绘制时 | 绘制场景内容 |

#### 场景示例：StartScene (scene1)

**scene1.h / scene1.cpp - 开始场景**

```cpp
// scene1.h - 声明 6 个函数
void LoadScene_StartScene();
void UnloadScene_StartScene();
void ProcessUiInput_StartScene();
void CheckCollision_StartScene();
void UpdateScene_StartScene(double deltaTime);
void RenderScene_StartScene(HDC hdc_memBuffer, HDC hdc_loadBmp);

// scene1.cpp - 实现这些函数
void LoadScene_StartScene()
{
    // 创建开始按钮
    ButtonId startButton = CreateButton(
        x, y, width, height,
        RenderStartButton,    // 如何绘制按钮
        OnStartButtonClick    // 点击后做什么
    );
    EnableButton(startButton);
}

void ProcessUiInput_StartScene()
{
    // 处理鼠标点击按钮
    if (IsMouseLButtonDown())
    {
        PressButtons(GetMouseX(), GetMouseY());
    }
}

void RenderScene_StartScene(HDC hdc_memBuffer, HDC hdc_loadBmp)
{
    // 绘制标题文字
    // 绘制按钮（会自动调用 RenderStartButton）
}
```

### 4.2 游戏对象

#### player.h / player.cpp - 玩家

**玩家结构体**：

```cpp
struct Player
{
    Vector2 position;     // 位置 (x, y)
    double width;         // 宽度
    double height;        // 高度
    Attribute attributes; // 属性（生命、分数、速度等）
};
```

**主要函数**：

```cpp
// 创建玩家
void CreatePlayer();

// 更新玩家（处理移动、发射子弹等）
void UpdatePlayer(double deltaTime);

// 绘制玩家
void RenderPlayer(HDC hdc_memBuffer, HDC hdc_loadBmp);

// 销毁玩家
void DestroyPlayer();

// 获取玩家指针
Player* GetPlayer();
```

#### enemy.h / enemy.cpp - 敌人

**敌人管理**：

因为游戏中有多个敌人，所以使用 `std::vector` 管理：

```cpp
// 创建一个敌人
void CreateEnemy(double x, double y);

// 创建随机位置的敌人
void CreateRandomEnemy();

// 更新所有敌人
void UpdateEnemies(double deltaTime);

// 绘制所有敌人
void RenderEnemies(HDC hdc_memBuffer, HDC hdc_loadBmp);

// 销毁指定敌人
void DestroyEnemy(Enemy* enemy);

// 销毁所有敌人
void DestroyEnemies();

// 获取所有敌人
std::vector<Enemy*> GetEnemies();
```

#### bullet.h / bullet.cpp - 子弹

**子弹管理**：

与敌人类似，使用 `std::vector` 管理多个子弹。

### 4.3 UI 组件

#### button.h / button.cpp - 按钮

**按钮系统**：

```cpp
// 创建按钮
ButtonId CreateButton(
    double x, double y,           // 位置
    int width, int height,         // 大小
    RenderButtonFunc renderFunc,   // 绘制函数
    OnClickButtonFunc clickFunc    // 点击回调函数
);

// 启用/禁用按钮
void EnableButton(ButtonId id);
void DisableButton(ButtonId id);

// 点击按钮（自动检测鼠标是否在按钮上）
void PressButtons(int mouseX, int mouseY);
```

**使用示例**：

```cpp
// 1. 定义绘制函数
void RenderStartButton(Button* button, HDC hdc_memBuffer, HDC hdc_loadBmp)
{
    // 绘制按钮图片
    SelectObject(hdc_loadBmp, bmp_StartButton);
    TransparentBlt(hdc_memBuffer, button->x, button->y, ...);
}

// 2. 定义点击回调函数
void OnStartButtonClick(Button* button)
{
    // 切换到游戏场景
    ChangeScene(GameScene);
}

// 3. 创建按钮
ButtonId id = CreateButton(100, 200, 300, 100, 
                           RenderStartButton, 
                           OnStartButtonClick);
```

## 五、工具函数 (util)

### 5.1 type.h - 数据类型定义

```cpp
// 二维向量（用于表示位置、方向等）
struct Vector2
{
    double x;
    double y;
};

// 游戏对象属性
struct Attribute
{
    int health;           // 生命值
    int score;            // 分数
    double speed;         // 速度
    double maxBulletCd;   // 最大子弹冷却时间
    double bulletCd;      // 当前子弹冷却时间
};

// 矩形（用于碰撞检测）
struct Rect
{
    double left, right, top, bottom;
};

// 圆形（用于碰撞检测）
struct Circle
{
    Vector2 center;
    double radius;
};
```

### 5.2 util.h / util.cpp - 工具函数

**数学函数**：

```cpp
// 向量归一化（变成长度为 1 的向量）
Vector2 Normalize(Vector2 v);

// 计算向量长度
double Length(Vector2 v);

// 生成随机数
double GetRandomDouble(double min, double max);
int GetRandomInt(int min, int max);
```

**碰撞检测**：

```cpp
// 矩形与矩形碰撞
bool IsRectRectCollision(Rect rect1, Rect rect2);

// 矩形与圆形碰撞
bool IsRectCircleCollision(Rect rect, Circle circle);

// 圆形与圆形碰撞
bool IsCircleCircleCollision(Circle circle1, Circle circle2);
```

## 六、数据流程

### 6.1 游戏启动流程

```
1. wWinMain 启动
   ↓
2. 创建窗口
   ↓
3. 触发 WM_CREATE 事件
   ↓
4. 调用 GameInit()
   ↓
5. 加载资源 GameResourceInit()
   ↓
6. 切换到开始场景 ChangeScene(StartScene)
   ↓
7. 调用 LoadScene_StartScene()
   ↓
8. 创建按钮等 UI 元素
   ↓
9. 进入消息循环
```

### 6.2 游戏循环流程

```
定时器触发 (每 16ms)
   ↓
调用 GameLoop()
   ↓
调用 SceneLoop()
   ↓
┌─────────────────────────┐
│ 如果需要切换场景：        │
│   - UnloadScene 旧场景   │
│   - LoadScene 新场景     │
└─────────────────────────┘
   ↓
ProcessUiInput()  ← 处理 UI 输入
   ↓
CheckCollision()  ← 检测碰撞
   ↓
UpdateScene()     ← 更新游戏逻辑
   ↓
请求重绘 InvalidateRect()
   ↓
触发 WM_PAINT 事件
   ↓
调用 GameRender()
   ↓
调用 RenderScene()
   ↓
显示画面
```

### 6.3 输入处理流程

**键盘输入**：
```
按下键盘 → WM_KEYDOWN 事件 → KeyDown() 记录状态
游戏逻辑中 → GetKeyDown() 查询状态 → 执行相应操作
松开键盘 → WM_KEYUP 事件 → KeyUp() 更新状态
```

**鼠标输入**：
```
移动鼠标 → WM_MOUSEMOVE 事件 → MouseMove() 记录位置
按下鼠标 → WM_LBUTTONDOWN 事件 → LButtonDown() 记录状态
游戏逻辑中 → GetMouseX(), IsMouseLButtonDown() → 执行操作
```

## 七、重要设计模式

### 7.1 单例模式

某些对象在游戏中只有一个实例（如玩家）：

```cpp
// 在 player.cpp 中
static Player* player = nullptr;  // 静态全局变量，只在本文件可见

Player* GetPlayer()
{
    return player;  // 返回唯一的玩家实例
}
```

### 7.2 对象池模式

对于大量动态创建销毁的对象（如子弹、敌人）：

```cpp
// 使用 vector 管理
static std::vector<Enemy*> enemies;

void CreateEnemy(double x, double y)
{
    Enemy* enemy = new Enemy();
    // 初始化...
    enemies.push_back(enemy);  // 加入池中
}

void DestroyEnemy(Enemy* enemy)
{
    auto it = std::find(enemies.begin(), enemies.end(), enemy);
    if (it != enemies.end())
    {
        enemies.erase(it);  // 从池中移除
        delete enemy;        // 释放内存
    }
}
```

### 7.3 回调函数模式

按钮使用回调函数处理点击事件：

```cpp
typedef void (*OnClickButtonFunc)(Button* button);

struct Button
{
    // ...
    OnClickButtonFunc onClick;  // 存储回调函数指针
};

void PressButtons(int x, int y)
{
    for (Button* btn : buttons)
    {
        if (/* 鼠标在按钮上 */)
        {
            btn->onClick(btn);  // 调用回调函数
        }
    }
}
```

## 八、内存管理

### 8.1 创建与销毁原则

**黄金法则**：在哪里创建，就在对应的地方销毁

```cpp
// LoadScene 中创建
void LoadScene_GameScene()
{
    CreatePlayer();    // 创建玩家
}

// UnloadScene 中销毁
void UnloadScene_GameScene()
{
    DestroyPlayer();   // 销毁玩家
}
```

### 8.2 内存泄漏预防

```cpp
// ✅ 正确：new 和 delete 配对
Player* player = new Player();
// 使用 player...
delete player;

// ❌ 错误：忘记 delete
Player* player = new Player();
// 使用 player...
// 忘记 delete，内存泄漏！

// ✅ 正确：数组的 new[] 和 delete[] 配对
int* arr = new int[100];
delete[] arr;

// ❌ 错误：用 delete 删除数组
int* arr = new int[100];
delete arr;  // 错误！应该用 delete[]
```

## 九、调试技巧

### 9.1 使用断点

```cpp
void UpdatePlayer(double deltaTime)
{
    Vector2 direction = {0, 0};
    
    // 在这里设置断点 (按 F9)
    if (GetKeyDown(VK_W))
    {
        direction.y -= 1;
    }
    
    // 程序运行到这里会暂停
    // 可以查看 direction 的值
}
```

### 9.2 日志输出

```cpp
// 使用 Log 函数输出调试信息
Log(1, TEXT("玩家位置: x=%d, y=%d"), (int)player->x, (int)player->y);
Log(1, TEXT("当前敌人数量: %d"), enemies.size());
```

### 9.3 常见问题排查

| 问题 | 可能原因 | 检查方法 |
|-----|---------|---------|
| 游戏崩溃 | 空指针访问 | 检查指针是否为 nullptr |
| 对象不显示 | 未调用 Render 函数 | 确认 RenderScene 中有绘制代码 |
| 对象不移动 | 未调用 Update 函数 | 确认 UpdateScene 中有更新代码 |
| 内存不断增长 | 内存泄漏 | 检查 new 和 delete 是否配对 |

## 十、下一步学习

现在你已经了解了整体框架，接下来可以：

1. 阅读 `docs/03-Win32基础.md` - 学习 Win32 绘图
2. 阅读 `docs/04-游戏核心.md` - 深入理解游戏循环
3. 阅读 `docs/05-场景系统.md` - 学习如何管理场景
4. 开始编写代码！

---

记住：**理解框架是实现功能的基础，慢慢来，不要着急！** 🚀
